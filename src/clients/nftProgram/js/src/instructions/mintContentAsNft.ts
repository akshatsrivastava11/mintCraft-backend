/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { MINT_CRAFT_NFT_PROGRAM_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  expectSome,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';

export const MINT_CONTENT_AS_NFT_DISCRIMINATOR = new Uint8Array([
  80, 232, 87, 202, 11, 234, 193, 128,
]);

export function getMintContentAsNftDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    MINT_CONTENT_AS_NFT_DISCRIMINATOR
  );
}

export type MintContentAsNftInstruction<
  TProgram extends string = typeof MINT_CRAFT_NFT_PROGRAM_PROGRAM_ADDRESS,
  TAccountContentAccount extends string | AccountMeta<string> = string,
  TAccountNftMetadata extends string | AccountMeta<string> = string,
  TAccountMint extends string | AccountMeta<string> = string,
  TAccountUserConfig extends string | AccountMeta<string> = string,
  TAccountConfig extends string | AccountMeta<string> = string,
  TAccountTokenAccount extends string | AccountMeta<string> = string,
  TAccountMetadata extends string | AccountMeta<string> = string,
  TAccountCreator extends string | AccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TAccountRent extends
    | string
    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TAccountAssociatedTokenProgram extends
    | string
    | AccountMeta<string> = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
  TAccountTokenMetadataProgram extends
    | string
    | AccountMeta<string> = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountContentAccount extends string
        ? WritableAccount<TAccountContentAccount>
        : TAccountContentAccount,
      TAccountNftMetadata extends string
        ? WritableAccount<TAccountNftMetadata>
        : TAccountNftMetadata,
      TAccountMint extends string
        ? WritableAccount<TAccountMint>
        : TAccountMint,
      TAccountUserConfig extends string
        ? ReadonlyAccount<TAccountUserConfig>
        : TAccountUserConfig,
      TAccountConfig extends string
        ? ReadonlyAccount<TAccountConfig>
        : TAccountConfig,
      TAccountTokenAccount extends string
        ? WritableAccount<TAccountTokenAccount>
        : TAccountTokenAccount,
      TAccountMetadata extends string
        ? WritableAccount<TAccountMetadata>
        : TAccountMetadata,
      TAccountCreator extends string
        ? WritableSignerAccount<TAccountCreator> &
            AccountSignerMeta<TAccountCreator>
        : TAccountCreator,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountRent extends string
        ? ReadonlyAccount<TAccountRent>
        : TAccountRent,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountAssociatedTokenProgram extends string
        ? ReadonlyAccount<TAccountAssociatedTokenProgram>
        : TAccountAssociatedTokenProgram,
      TAccountTokenMetadataProgram extends string
        ? ReadonlyAccount<TAccountTokenMetadataProgram>
        : TAccountTokenMetadataProgram,
      ...TRemainingAccounts,
    ]
  >;

export type MintContentAsNftInstructionData = {
  discriminator: ReadonlyUint8Array;
  contentId: bigint;
  nftName: string;
  nftSymbol: string;
};

export type MintContentAsNftInstructionDataArgs = {
  contentId: number | bigint;
  nftName: string;
  nftSymbol: string;
};

export function getMintContentAsNftInstructionDataEncoder(): Encoder<MintContentAsNftInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['contentId', getU64Encoder()],
      ['nftName', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
      ['nftSymbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ]),
    (value) => ({ ...value, discriminator: MINT_CONTENT_AS_NFT_DISCRIMINATOR })
  );
}

export function getMintContentAsNftInstructionDataDecoder(): Decoder<MintContentAsNftInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['contentId', getU64Decoder()],
    ['nftName', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ['nftSymbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
  ]);
}

export function getMintContentAsNftInstructionDataCodec(): Codec<
  MintContentAsNftInstructionDataArgs,
  MintContentAsNftInstructionData
> {
  return combineCodec(
    getMintContentAsNftInstructionDataEncoder(),
    getMintContentAsNftInstructionDataDecoder()
  );
}

export type MintContentAsNftAsyncInput<
  TAccountContentAccount extends string = string,
  TAccountNftMetadata extends string = string,
  TAccountMint extends string = string,
  TAccountUserConfig extends string = string,
  TAccountConfig extends string = string,
  TAccountTokenAccount extends string = string,
  TAccountMetadata extends string = string,
  TAccountCreator extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountRent extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountAssociatedTokenProgram extends string = string,
  TAccountTokenMetadataProgram extends string = string,
> = {
  contentAccount?: Address<TAccountContentAccount>;
  nftMetadata?: Address<TAccountNftMetadata>;
  mint?: Address<TAccountMint>;
  userConfig?: Address<TAccountUserConfig>;
  config?: Address<TAccountConfig>;
  tokenAccount?: Address<TAccountTokenAccount>;
  metadata: Address<TAccountMetadata>;
  creator: TransactionSigner<TAccountCreator>;
  systemProgram?: Address<TAccountSystemProgram>;
  rent?: Address<TAccountRent>;
  tokenProgram?: Address<TAccountTokenProgram>;
  associatedTokenProgram?: Address<TAccountAssociatedTokenProgram>;
  tokenMetadataProgram?: Address<TAccountTokenMetadataProgram>;
  contentId: MintContentAsNftInstructionDataArgs['contentId'];
  nftName: MintContentAsNftInstructionDataArgs['nftName'];
  nftSymbol: MintContentAsNftInstructionDataArgs['nftSymbol'];
};

export async function getMintContentAsNftInstructionAsync<
  TAccountContentAccount extends string,
  TAccountNftMetadata extends string,
  TAccountMint extends string,
  TAccountUserConfig extends string,
  TAccountConfig extends string,
  TAccountTokenAccount extends string,
  TAccountMetadata extends string,
  TAccountCreator extends string,
  TAccountSystemProgram extends string,
  TAccountRent extends string,
  TAccountTokenProgram extends string,
  TAccountAssociatedTokenProgram extends string,
  TAccountTokenMetadataProgram extends string,
  TProgramAddress extends
    Address = typeof MINT_CRAFT_NFT_PROGRAM_PROGRAM_ADDRESS,
>(
  input: MintContentAsNftAsyncInput<
    TAccountContentAccount,
    TAccountNftMetadata,
    TAccountMint,
    TAccountUserConfig,
    TAccountConfig,
    TAccountTokenAccount,
    TAccountMetadata,
    TAccountCreator,
    TAccountSystemProgram,
    TAccountRent,
    TAccountTokenProgram,
    TAccountAssociatedTokenProgram,
    TAccountTokenMetadataProgram
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  MintContentAsNftInstruction<
    TProgramAddress,
    TAccountContentAccount,
    TAccountNftMetadata,
    TAccountMint,
    TAccountUserConfig,
    TAccountConfig,
    TAccountTokenAccount,
    TAccountMetadata,
    TAccountCreator,
    TAccountSystemProgram,
    TAccountRent,
    TAccountTokenProgram,
    TAccountAssociatedTokenProgram,
    TAccountTokenMetadataProgram
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? MINT_CRAFT_NFT_PROGRAM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    contentAccount: { value: input.contentAccount ?? null, isWritable: true },
    nftMetadata: { value: input.nftMetadata ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: true },
    userConfig: { value: input.userConfig ?? null, isWritable: false },
    config: { value: input.config ?? null, isWritable: false },
    tokenAccount: { value: input.tokenAccount ?? null, isWritable: true },
    metadata: { value: input.metadata ?? null, isWritable: true },
    creator: { value: input.creator ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false,
    },
    tokenMetadataProgram: {
      value: input.tokenMetadataProgram ?? null,
      isWritable: false,
    },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.contentAccount.value) {
    accounts.contentAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([99, 111, 110, 116, 101, 110, 116])
        ),
        getU64Encoder().encode(expectSome(args.contentId)),
      ],
    });
  }
  if (!accounts.nftMetadata.value) {
    accounts.nftMetadata.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            110, 102, 116, 95, 109, 101, 116, 97, 100, 97, 116, 97,
          ])
        ),
        getU64Encoder().encode(expectSome(args.contentId)),
      ],
    });
  }
  if (!accounts.mint.value) {
    accounts.mint.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([109, 105, 110, 116])),
        getU64Encoder().encode(expectSome(args.contentId)),
      ],
    });
  }
  if (!accounts.config.value) {
    accounts.config.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([99, 111, 110, 102, 105, 103])),
      ],
    });
  }
  if (!accounts.userConfig.value) {
    accounts.userConfig.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([117, 115, 101, 114, 95, 99, 111, 110, 102, 105, 103])
        ),
        getAddressEncoder().encode(expectAddress(accounts.config.value)),
        getAddressEncoder().encode(expectAddress(accounts.creator.value)),
      ],
    });
  }
  if (!accounts.tokenAccount.value) {
    accounts.tokenAccount.value = await getProgramDerivedAddress({
      programAddress:
        'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,
      seeds: [
        getAddressEncoder().encode(expectAddress(accounts.creator.value)),
        getBytesEncoder().encode(
          new Uint8Array([
            6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70, 206, 235,
            121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58, 140, 245, 133,
            126, 255, 0, 169,
          ])
        ),
        getAddressEncoder().encode(expectAddress(accounts.mint.value)),
      ],
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.rent.value) {
    accounts.rent.value =
      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }
  if (!accounts.tokenMetadataProgram.value) {
    accounts.tokenMetadataProgram.value =
      'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.contentAccount),
      getAccountMeta(accounts.nftMetadata),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.userConfig),
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.tokenAccount),
      getAccountMeta(accounts.metadata),
      getAccountMeta(accounts.creator),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.tokenMetadataProgram),
    ],
    programAddress,
    data: getMintContentAsNftInstructionDataEncoder().encode(
      args as MintContentAsNftInstructionDataArgs
    ),
  } as MintContentAsNftInstruction<
    TProgramAddress,
    TAccountContentAccount,
    TAccountNftMetadata,
    TAccountMint,
    TAccountUserConfig,
    TAccountConfig,
    TAccountTokenAccount,
    TAccountMetadata,
    TAccountCreator,
    TAccountSystemProgram,
    TAccountRent,
    TAccountTokenProgram,
    TAccountAssociatedTokenProgram,
    TAccountTokenMetadataProgram
  >;

  return instruction;
}

export type MintContentAsNftInput<
  TAccountContentAccount extends string = string,
  TAccountNftMetadata extends string = string,
  TAccountMint extends string = string,
  TAccountUserConfig extends string = string,
  TAccountConfig extends string = string,
  TAccountTokenAccount extends string = string,
  TAccountMetadata extends string = string,
  TAccountCreator extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountRent extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountAssociatedTokenProgram extends string = string,
  TAccountTokenMetadataProgram extends string = string,
> = {
  contentAccount: Address<TAccountContentAccount>;
  nftMetadata: Address<TAccountNftMetadata>;
  mint: Address<TAccountMint>;
  userConfig: Address<TAccountUserConfig>;
  config: Address<TAccountConfig>;
  tokenAccount: Address<TAccountTokenAccount>;
  metadata: Address<TAccountMetadata>;
  creator: TransactionSigner<TAccountCreator>;
  systemProgram?: Address<TAccountSystemProgram>;
  rent?: Address<TAccountRent>;
  tokenProgram?: Address<TAccountTokenProgram>;
  associatedTokenProgram?: Address<TAccountAssociatedTokenProgram>;
  tokenMetadataProgram?: Address<TAccountTokenMetadataProgram>;
  contentId: MintContentAsNftInstructionDataArgs['contentId'];
  nftName: MintContentAsNftInstructionDataArgs['nftName'];
  nftSymbol: MintContentAsNftInstructionDataArgs['nftSymbol'];
};

export function getMintContentAsNftInstruction<
  TAccountContentAccount extends string,
  TAccountNftMetadata extends string,
  TAccountMint extends string,
  TAccountUserConfig extends string,
  TAccountConfig extends string,
  TAccountTokenAccount extends string,
  TAccountMetadata extends string,
  TAccountCreator extends string,
  TAccountSystemProgram extends string,
  TAccountRent extends string,
  TAccountTokenProgram extends string,
  TAccountAssociatedTokenProgram extends string,
  TAccountTokenMetadataProgram extends string,
  TProgramAddress extends
    Address = typeof MINT_CRAFT_NFT_PROGRAM_PROGRAM_ADDRESS,
>(
  input: MintContentAsNftInput<
    TAccountContentAccount,
    TAccountNftMetadata,
    TAccountMint,
    TAccountUserConfig,
    TAccountConfig,
    TAccountTokenAccount,
    TAccountMetadata,
    TAccountCreator,
    TAccountSystemProgram,
    TAccountRent,
    TAccountTokenProgram,
    TAccountAssociatedTokenProgram,
    TAccountTokenMetadataProgram
  >,
  config?: { programAddress?: TProgramAddress }
): MintContentAsNftInstruction<
  TProgramAddress,
  TAccountContentAccount,
  TAccountNftMetadata,
  TAccountMint,
  TAccountUserConfig,
  TAccountConfig,
  TAccountTokenAccount,
  TAccountMetadata,
  TAccountCreator,
  TAccountSystemProgram,
  TAccountRent,
  TAccountTokenProgram,
  TAccountAssociatedTokenProgram,
  TAccountTokenMetadataProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? MINT_CRAFT_NFT_PROGRAM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    contentAccount: { value: input.contentAccount ?? null, isWritable: true },
    nftMetadata: { value: input.nftMetadata ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: true },
    userConfig: { value: input.userConfig ?? null, isWritable: false },
    config: { value: input.config ?? null, isWritable: false },
    tokenAccount: { value: input.tokenAccount ?? null, isWritable: true },
    metadata: { value: input.metadata ?? null, isWritable: true },
    creator: { value: input.creator ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false,
    },
    tokenMetadataProgram: {
      value: input.tokenMetadataProgram ?? null,
      isWritable: false,
    },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.rent.value) {
    accounts.rent.value =
      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }
  if (!accounts.tokenMetadataProgram.value) {
    accounts.tokenMetadataProgram.value =
      'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.contentAccount),
      getAccountMeta(accounts.nftMetadata),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.userConfig),
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.tokenAccount),
      getAccountMeta(accounts.metadata),
      getAccountMeta(accounts.creator),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.tokenMetadataProgram),
    ],
    programAddress,
    data: getMintContentAsNftInstructionDataEncoder().encode(
      args as MintContentAsNftInstructionDataArgs
    ),
  } as MintContentAsNftInstruction<
    TProgramAddress,
    TAccountContentAccount,
    TAccountNftMetadata,
    TAccountMint,
    TAccountUserConfig,
    TAccountConfig,
    TAccountTokenAccount,
    TAccountMetadata,
    TAccountCreator,
    TAccountSystemProgram,
    TAccountRent,
    TAccountTokenProgram,
    TAccountAssociatedTokenProgram,
    TAccountTokenMetadataProgram
  >;

  return instruction;
}

export type ParsedMintContentAsNftInstruction<
  TProgram extends string = typeof MINT_CRAFT_NFT_PROGRAM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    contentAccount: TAccountMetas[0];
    nftMetadata: TAccountMetas[1];
    mint: TAccountMetas[2];
    userConfig: TAccountMetas[3];
    config: TAccountMetas[4];
    tokenAccount: TAccountMetas[5];
    metadata: TAccountMetas[6];
    creator: TAccountMetas[7];
    systemProgram: TAccountMetas[8];
    rent: TAccountMetas[9];
    tokenProgram: TAccountMetas[10];
    associatedTokenProgram: TAccountMetas[11];
    tokenMetadataProgram: TAccountMetas[12];
  };
  data: MintContentAsNftInstructionData;
};

export function parseMintContentAsNftInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedMintContentAsNftInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 13) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      contentAccount: getNextAccount(),
      nftMetadata: getNextAccount(),
      mint: getNextAccount(),
      userConfig: getNextAccount(),
      config: getNextAccount(),
      tokenAccount: getNextAccount(),
      metadata: getNextAccount(),
      creator: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      tokenProgram: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      tokenMetadataProgram: getNextAccount(),
    },
    data: getMintContentAsNftInstructionDataDecoder().decode(instruction.data),
  };
}
